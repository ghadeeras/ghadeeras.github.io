import { DeferredComputation } from "../scheduling.js";
import { save } from "../files.js";
import { keysOf } from "../utils.js";
export class CanvasSizeManager {
    constructor(devicePixels = false) {
        this.devicePixels = devicePixels;
        this.observer = new ResizeObserver(entries => this.onResize(entries));
        this.resizing = new DeferredComputation(() => this.resizeAll());
        this.observed = new Map();
        this.dirtyCanvas = new Map();
    }
    observe(canvas, handler) {
        try {
            this.observer.observe(canvas, { box: this.devicePixels ? "device-pixel-content-box" : "content-box" });
        }
        catch (e) {
            console.warn("Falling back to observing content box because of error!", e);
            this.observer.observe(canvas, { box: "content-box" });
        }
        this.observed.set(canvas, handler);
    }
    onResize(entries) {
        for (const entry of entries) {
            const [width, height] = this.getSize(entry);
            const canvas = entry.target;
            this.dirtyCanvas.set(canvas, [width, height]);
        }
        this.resizing.perform();
    }
    getSize(entry) {
        const dpr = this.dpr();
        if (this.devicePixels && entry.devicePixelContentBoxSize?.length > 0) {
            return asTuple(entry.devicePixelContentBoxSize[0]);
        }
        else if (entry.contentBoxSize?.length > 0) {
            const [width, height] = asTuple(entry.contentBoxSize[0]);
            return [Math.round(width * dpr), Math.round(height * dpr)];
        }
        else {
            return [Math.round(entry.contentRect.width * dpr), Math.round(entry.contentRect.height * dpr)];
        }
    }
    dpr() {
        return this.devicePixels ? window.devicePixelRatio : 1;
    }
    resizeAll() {
        try {
            this.doResizeAll();
        }
        finally {
            this.dirtyCanvas.clear();
        }
    }
    doResizeAll() {
        for (const [canvas, [width, height]] of this.dirtyCanvas) {
            const needsResizing = (width !== canvas.width || height !== canvas.height);
            if (needsResizing) {
                canvas.width = width;
                canvas.height = height;
                this.invokeHandler(canvas);
            }
        }
    }
    invokeHandler(canvas) {
        const handler = this.observed.get(canvas);
        if (handler !== undefined) {
            try {
                handler(canvas);
            }
            catch (e) {
                console.error(e);
            }
        }
    }
}
const preferredVideoMimeTypes = {
    "video/mp4": "video.mp4",
    "video/webm": "video.webm"
};
export class CanvasRecorder {
    constructor(canvas) {
        this.canvas = canvas;
        this._videoStream = null;
        this._videoRecorder = null;
        this.chunks = [];
        this.fileName = "video.mp4";
    }
    init() {
        const bps = 2 ** Math.floor(Math.log2(this.canvas.width * this.canvas.height * 24)); // just a heuristic
        const videoStream = this.canvas.captureStream();
        const videoRecorder = this.newVideoRecorder(videoStream, bps);
        videoRecorder.ondataavailable = e => this.chunks.push(e.data);
        console.log(`Recorder mime type: ${videoRecorder.mimeType}`);
        console.log(`Recorder video bps: ${videoRecorder.videoBitsPerSecond}`);
        videoRecorder.onstop = () => {
            const blob = new Blob(this.chunks);
            const url = URL.createObjectURL(blob);
            save(url, videoRecorder.mimeType, this.fileName);
            this.chunks = [];
        };
        return [this._videoRecorder, this._videoStream] = [videoRecorder, videoStream];
    }
    newVideoRecorder(videoStream, bps) {
        let videoRecorder = null;
        for (const mimeType of keysOf(preferredVideoMimeTypes)) {
            videoRecorder = MediaRecorder.isTypeSupported(mimeType)
                ? new MediaRecorder(videoStream, { audioBitsPerSecond: 0, videoBitsPerSecond: bps, mimeType })
                : null;
            if (videoRecorder !== null) {
                console.info("Supported video recording mime type: " + mimeType);
                this.fileName = preferredVideoMimeTypes[mimeType];
                return videoRecorder;
            }
        }
        throw new Error("Preferred video mime types are not supported: " + Object.keys(preferredVideoMimeTypes));
    }
    get videoStream() {
        return this._videoStream;
    }
    get videoRecorder() {
        return this._videoRecorder;
    }
    get state() {
        return this.videoRecorder?.state ?? "inactive";
    }
    startStop(fileName = this.fileName) {
        if (this.state === "recording") {
            this.stop(fileName);
        }
        else {
            this.start();
        }
    }
    start() {
        if (this.state !== "recording") {
            const [vr, _] = this.init();
            vr.start();
        }
    }
    stop(fileName = this.fileName) {
        if (this.state === "recording") {
            this.fileName = fileName;
            this.videoRecorder?.stop();
            [this._videoRecorder, this._videoStream] = [null, null];
        }
    }
}
function asTuple(size) {
    return [size.inlineSize, size.blockSize];
}
