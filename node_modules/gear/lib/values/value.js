export function value(value, equality = (a, b) => a === b) {
    return new BasicValue(value, equality);
}
export function record(values) {
    return new RecordValue(values);
}
export function array(values) {
    return new ArrayValue(values);
}
export function tuple(values) {
    return array(values);
}
export function from(v) {
    const s = structure(v);
    return s instanceof Value ? s : value(s);
}
function structure(value) {
    let result = value;
    if (value instanceof Value) {
        result = value;
    }
    else if (Array.isArray(value)) {
        const a = value.map(v => structure(v));
        result = a.some(v => v instanceof Value) ? array(a) : a;
    }
    else if (typeof value === 'object' && value !== null) {
        const r = {};
        for (const [key, val] of Object.entries(value)) {
            r[key] = structure(val);
        }
        result = Object.values(r).some(v => v instanceof Value) ? record(r) : r;
    }
    return result;
}
export class Value {
    constructor() {
        this.sources = [];
        this.listeners = [];
    }
    addSource(source, listener) {
        source.addListener(listener);
        this.sources.push([source, listener]);
    }
    removeSource(source) {
        this.sources = this.sources.filter(([s, l]) => {
            const isSourceToRemove = s === source;
            if (isSourceToRemove) {
                s.removeListener(l);
            }
            return !isSourceToRemove;
        });
    }
    addListener(listener) {
        if (this.listeners.length === 0) {
            this.connectSources();
        }
        if (!this.listeners.includes(listener)) {
            this.listeners.push(listener);
            listener();
        }
    }
    removeListener(listener) {
        this.listeners = this.listeners.filter(l => l !== listener);
        if (this.listeners.length === 0) {
            this.disconnectSources();
        }
    }
    connectSources() {
        this.sources.forEach(([source, listener]) => source.addListener(listener));
    }
    disconnectSources() {
        this.sources.forEach(([source, listener]) => source.removeListener(listener));
    }
    notifyListeners() {
        for (const listener of this.listeners) {
            listener();
        }
    }
    map(mapper) {
        return new MappedValue(this, mapper);
    }
    flatMap(mapper) {
        return new FlattenedValue(this.map(mapper));
    }
    mapToRecord(mapper) {
        return this.map(mapper).flatMap(value => record(value));
    }
    mapToArray(mapper) {
        return this.map(mapper).flatMap(value => array(value));
    }
    mapToTuple(mapper) {
        return this.map(mapper).flatMap(value => tuple(value));
    }
    cached() {
        return new CachedValue(this);
    }
    to(consumer) {
        this.addListener(() => setTimeout(async () => consumer(await this.get())));
        return this;
    }
}
class MappedValue extends Value {
    constructor(value, mapper) {
        super();
        this.value = value;
        this.mapper = mapper;
        this.addSource(this.value, () => this.notifyListeners());
    }
    async get() {
        const value = await this.value.get();
        return await this.mapper(value);
    }
}
class FlattenedValue extends Value {
    constructor(value) {
        super();
        this.value = value;
        this.nestedValue = null;
        this.addSource(this.value, () => this.notifyListeners());
    }
    async get() {
        const nestedValue = await this.value.get();
        if (this.nestedValue !== nestedValue) {
            if (this.nestedValue !== null) {
                this.removeSource(this.nestedValue);
            }
            this.nestedValue = nestedValue;
            this.addSource(nestedValue, () => this.notifyListeners());
        }
        return await nestedValue.get();
    }
}
class CachedValue extends Value {
    constructor(value) {
        super();
        this.value = value;
        this.cachedValue = null;
        this.addSource(this.value, () => {
            this.cachedValue = null;
            this.notifyListeners();
        });
    }
    async get() {
        if (this.cachedValue === null) {
            this.cachedValue = await this.value.get();
        }
        return this.cachedValue;
    }
}
export class BasicValue extends Value {
    constructor(value, equality) {
        super();
        this.value = value;
        this.equality = equality;
    }
    async get() {
        return this.value;
    }
    set(value) {
        const oldValue = this.value;
        if (!this.equality(oldValue, value)) {
            this.value = value;
            this.notifyListeners();
        }
        return oldValue;
    }
}
class RecordValue extends Value {
    constructor(values) {
        super();
        this.values = values;
        for (const value of Object.values(values)) {
            if (value instanceof Value) {
                this.addSource(value, () => this.notifyListeners());
            }
        }
    }
    async get() {
        const result = {};
        for (const [key, value] of Object.entries(this.values)) {
            result[key] = await get(value);
        }
        return result;
    }
}
class ArrayValue extends Value {
    constructor(values) {
        super();
        this.values = values;
        for (const value of values) {
            if (value instanceof Value) {
                this.addSource(value, () => this.notifyListeners());
            }
        }
    }
    async get() {
        return Promise.all(this.values.map(async (value) => await get(value)));
    }
}
async function get(value) {
    return value instanceof Value ? await value.get() : value;
}
