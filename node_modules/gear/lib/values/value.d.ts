import { Consumer, Tuple } from "../types.js";
export type InferFrom<V> = V extends Value<infer T> ? T : V;
export type InferFromRecord<V extends Record<string, any>> = {
    [K in keyof V]: InferFrom<V[K]>;
};
export type InferFromTuple<P extends Tuple> = P extends [infer H, ...infer T] ? T extends Tuple ? [InferFrom<H>, ...InferFromTuple<T>] : [InferFrom<H>, InferFrom<T>] : [];
export type DeepInferFrom<V> = V extends Value<infer T> ? T : V extends (infer T)[] ? DeepInferFrom<T>[] : V extends Record<string, any> ? DeepInferFromRecord<V> : V;
export type DeepInferFromRecord<V extends Record<string, any>> = {
    [K in keyof V]: DeepInferFrom<V[K]>;
};
export type DeepInferFromTuple<P extends Tuple> = P extends [infer H, ...infer T] ? T extends Tuple ? [DeepInferFrom<H>, ...DeepInferFromTuple<T>] : [DeepInferFrom<H>, DeepInferFrom<T>] : [];
export declare function value<T>(value: T, equality?: (a: T, b: T) => boolean): BasicValue<T>;
export declare function record<V extends Record<string, any>>(values: V): Value<InferFromRecord<V>>;
export declare function array<T>(values: (T | Value<T>)[]): Value<T[]>;
export declare function tuple<P extends Tuple>(values: P): Value<InferFromTuple<P>>;
export declare function from<T>(v: T): Value<DeepInferFrom<T>>;
export declare abstract class Value<T> {
    private sources;
    private listeners;
    protected addSource<S>(source: Value<S>, listener: () => void): void;
    protected removeSource<S>(source: Value<S>): void;
    abstract get(): Promise<T>;
    addListener(listener: () => void): void;
    removeListener(listener: () => void): void;
    private connectSources;
    private disconnectSources;
    protected notifyListeners(): void;
    map<R>(mapper: (value: T) => R | Promise<R>): Value<R>;
    flatMap<R>(mapper: (value: T) => Value<R> | Promise<Value<R>>): Value<R>;
    mapToRecord<R extends Record<string, any>>(mapper: (value: T) => R | Promise<R>): Value<InferFromRecord<R>>;
    mapToArray<R extends any[]>(mapper: (value: T) => (R | Value<R>)[] | Promise<(R | Value<R>)[]>): Value<R[]>;
    mapToTuple<R extends Tuple>(mapper: (value: T) => R | Promise<R>): Value<InferFromTuple<R>>;
    cached(): Value<T>;
    to(consumer: Consumer<T>): Value<T>;
}
export declare class BasicValue<T> extends Value<T> {
    private value;
    private equality;
    constructor(value: T, equality: (a: T, b: T) => boolean);
    get(): Promise<T>;
    set(value: T): T;
}
