import * as vec from "./vector.js";
export type Mat<D extends vec.Dim> = vec.Tuple<vec.Vec<D>, D>;
export type Mat2 = Mat<2>;
export type Mat3 = Mat<3>;
export type Mat4 = Mat<4>;
export interface MatMath<D extends vec.Dim> {
    from(array: vec.NumberArray, offset?: number): Mat<D>;
    gen(...columns: [() => vec.Vec<D>] | vec.Tuple<() => vec.Vec<D>, D>): () => Mat<D>;
    identity(): Mat<D>;
    diagonal(...d: vec.Vec<D>): Mat<D>;
    outer(v1: vec.Vec<D>, v2: vec.Vec<D>): Mat<D>;
    projectionOn(v: vec.Vec<D>): Mat<D>;
    apply(m: Mat<D>, v: vec.Vec<D>): vec.Vec<D>;
    neg(m: Mat<D>): Mat<D>;
    scale(m: Mat<D>, f: number): Mat<D>;
    add(m1: Mat<D>, m2: Mat<D>): Mat<D>;
    sub(m1: Mat<D>, m2: Mat<D>): Mat<D>;
    mul(m1: Mat<D>, m2: Mat<D>): Mat<D>;
    determinant(m: Mat<D>): number;
    transpose(m: Mat<D>): Mat<D>;
    inverse(m: Mat<D>): Mat<D>;
    columnMajorArray(m: Mat<D>): number[];
}
export declare class Mat4Math implements MatMath<4> {
    from(array: vec.NumberArray, offset?: number): Mat4;
    gen(...columns: [() => vec.Vec4] | vec.Tuple<() => vec.Vec4, 4>): () => Mat4;
    identity(): Mat4;
    diagonal(...d: vec.Vec4): Mat4;
    outer(v1: vec.Vec4, v2: vec.Vec4): Mat4;
    projectionOn(v: vec.Vec4): Mat4;
    scalingAlong(v: vec.Vec3, parallel?: number, perpendicular?: number): Mat4;
    scaling(...diagonal: vec.Vec3): Mat4;
    translation(t: vec.Vec3): Mat4;
    rotationX(angle: number): Mat4;
    rotationY(angle: number): Mat4;
    rotationZ(angle: number): Mat4;
    rotation(angle: number, axis: vec.Vec3): Mat4;
    crossProdRotation(v1: vec.Vec3, v2: vec.Vec3, power?: number): Mat4;
    lookTowards(pos: vec.Vec3, dir?: vec.Vec3, up?: vec.Vec3): Mat4;
    lookAt(pos: vec.Vec3, objPos?: vec.Vec3, up?: vec.Vec3): [[number, number, number, number], [number, number, number, number], [number, number, number, number], [number, number, number, number]];
    projection(zoom?: number, near?: number, far?: number, aspectRatio?: number): Mat4;
    translated(m: Mat3, t: vec.Vec3): Mat4;
    affine(m: Mat3, t: vec.Vec3): Mat4;
    cast(m: Mat2 | Mat3): Mat4;
    apply(m: Mat4, v: vec.Vec4): vec.Vec4;
    neg(m: Mat4): Mat4;
    scale(m: Mat4, f: number): Mat4;
    add(m1: Mat4, m2: Mat4): Mat4;
    sub(m1: Mat4, m2: Mat4): Mat4;
    mul(m1: Mat4, m2: Mat4): Mat4;
    determinant(m: Mat4): number;
    transpose(m: Mat4): Mat4;
    inverse(m: Mat4): Mat4;
    columnMajorArray(m: Mat4): number[];
    private minor;
    private subMat;
}
export declare class Mat3Math implements MatMath<3> {
    from(array: vec.NumberArray, offset?: number): Mat3;
    gen(...columns: [() => vec.Vec3] | vec.Tuple<() => vec.Vec3, 3>): () => Mat3;
    identity(): Mat3;
    diagonal(...d: vec.Vec3): Mat3;
    outer(v1: vec.Vec3, v2: vec.Vec3): Mat3;
    projectionOn(v: vec.Vec3): Mat3;
    scalingAlong(v: vec.Vec3, parallel?: number, perpendicular?: number): Mat3;
    scaling(...diagonal: vec.Vec3): Mat3;
    rotationX(angle: number): Mat3;
    rotationY(angle: number): Mat3;
    rotationZ(angle: number): Mat3;
    rotation(angle: number, axis: vec.Vec3): Mat3;
    crossProdRotation(v1: vec.Vec3, v2: vec.Vec3, power?: number): Mat3;
    private rotMat;
    lookTowards(dir: vec.Vec3, up?: vec.Vec3): Mat3;
    cast(m: Mat2): Mat3;
    apply(m: Mat3, v: vec.Vec3): vec.Vec3;
    neg(m: Mat3): Mat3;
    scale(m: Mat3, f: number): Mat3;
    add(m1: Mat3, m2: Mat3): Mat3;
    sub(m1: Mat3, m2: Mat3): Mat3;
    mul(m1: Mat3, m2: Mat3): Mat3;
    determinant(m: Mat3): number;
    transpose(m: Mat3): Mat3;
    inverse(m: Mat3): Mat3;
    columnMajorArray(m: Mat3): number[];
}
export declare class Mat2Math implements MatMath<2> {
    from(array: vec.NumberArray, offset?: number): Mat2;
    gen(...columns: [() => vec.Vec2] | vec.Tuple<() => vec.Vec2, 2>): () => Mat2;
    identity(): Mat2;
    diagonal(...d: vec.Vec2): Mat2;
    outer(v1: vec.Vec2, v2: vec.Vec2): Mat2;
    projectionOn(v: vec.Vec2): Mat2;
    scalingAlong(v: vec.Vec2, parallel?: number, perpendicular?: number): Mat2;
    scaling(...diagonal: vec.Vec2): Mat2;
    rotation(angle: number): Mat2;
    apply(m: Mat2, v: vec.Vec2): vec.Vec2;
    neg(m: Mat2): Mat2;
    scale(m: Mat2, f: number): Mat2;
    add(m1: Mat2, m2: Mat2): Mat2;
    sub(m1: Mat2, m2: Mat2): Mat2;
    mul(m1: Mat2, m2: Mat2): Mat2;
    determinant(m: Mat2): number;
    transpose(m: Mat2): Mat2;
    inverse(m: Mat2): Mat2;
    columnMajorArray(m: Mat2): number[];
}
export declare function coordinateSystem<D extends vec.Dim>(math: MatMath<D>, s: Mat<D>): (m: Mat<D>) => Mat<D>;
export declare const mat4: Mat4Math;
export declare const mat3: Mat3Math;
export declare const mat2: Mat2Math;
