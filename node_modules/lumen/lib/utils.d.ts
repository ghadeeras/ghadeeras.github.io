export type Only<T, K extends keyof T> = {
    [k in K]: T[k];
} & {
    [k in Exclude<keyof T, K>]?: never;
};
export type IfSet<T, K extends keyof T, R> = T[K] extends (object | any[] | string | number | boolean | symbol) ? R : never;
export type Redefine<T, K extends keyof T, V> = {
    [k in keyof T]: k extends K ? V : T[k];
};
export type ReplaceValues<T extends Record<string, any>, V> = {
    [k in keyof T]: V;
};
export type StrictExclude<T, S extends T> = Exclude<T, S>;
export type Supplier<T> = () => T;
export declare function replaceValues<R extends Record<string, any>, B>(record: R, replace: (value: R[keyof R], key: string & (keyof R)) => B): ReplaceValues<R, B>;
export declare function failure<T>(message: string): T;
export declare function required<T>(value: T | null | undefined, message?: (v: null | undefined) => string): T;
export declare function lazily<T>(constructor: Supplier<T>): Supplier<T>;
export declare function values<K extends string | number | symbol, V>(record: Record<K, V>): V[];
export declare function later(): Promise<void>;
export declare function timeOut<T>(promise: Promise<T>, timeInMilliseconds: number, tag: string): Promise<T>;
