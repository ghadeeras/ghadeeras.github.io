import * as pln from "./pipeline.js";
import { Device } from "./device.js";
export declare class CommandEncoder {
    readonly device: Device;
    readonly wrapped: GPUCommandEncoder;
    readonly descriptor: Readonly<GPUCommandEncoderDescriptor>;
    constructor(label: string, device: Device);
    finish(): GPUCommandBuffer;
    computePass<T>(passSetter: (pass: GPUComputePassEncoder) => T): T;
    renderPass<T>(descriptor: GPURenderPassDescriptor, passSetter: (pass: GPURenderPassEncoder) => T): T;
}
export declare abstract class Pass<E extends GPUComputePassEncoder | GPURenderPassEncoder> {
    private device;
    private label;
    protected constructor(device: Device, label: string);
    enqueue(): void;
    commandBuffer(): GPUCommandBuffer;
    encode(encoder: CommandEncoder): CommandEncoder;
    protected abstract pass(label: string, encoder: CommandEncoder, encoding: (passEncoder: E) => void): void;
    abstract inlineIn(passEncoder: E): E;
}
export declare class ComputePass extends Pass<GPUComputePassEncoder> {
    private encoding;
    constructor(device: Device, label: string, encoding: (passEncoder: GPUComputePassEncoder) => void);
    protected pass(label: string, encoder: CommandEncoder, encoding: (passEncoder: GPUComputePassEncoder) => void): void;
    inlineIn(passEncoder: GPUComputePassEncoder): GPUComputePassEncoder;
}
export declare class ComputePassBuilder<D extends pln.PipelineLayoutDescriptor> {
    private pipeline;
    private groups;
    constructor(pipeline: pln.ComputePipeline<D>, groups: Partial<pln.PipelineEntries<D>>);
    dispatchWorkGroups(workgroupCountX: number, workgroupCountY?: number, workgroupCountZ?: number): ComputePass;
    dispatchWorkGroupsIndirect(indirectBuffer: GPUBuffer, indirectOffset: number): ComputePass;
    private init;
}
