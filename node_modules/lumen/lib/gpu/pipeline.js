export class PipelineLayout {
    constructor(device, label, descriptor) {
        this.device = device;
        this.label = label;
        this.descriptor = descriptor;
        const entries = descriptor.bindGroupLayouts;
        const groups = Object.values(entries).map(g => g.group);
        const count = groups.length > 0 ? 1 + Math.max(...groups) : 0;
        const bindGroupLayouts = new Array(count);
        for (const k of Object.keys(entries)) {
            const entry = entries[k];
            bindGroupLayouts[entry.group] = entry.layout.wrapped;
        }
        this.wrapped = device.wrapped.createPipelineLayout({
            label,
            bindGroupLayouts
        });
    }
    computeInstance(module, entryPoint) {
        return new ComputePipeline(this, module, entryPoint);
    }
    addTo(pass, groups) {
        for (const k of Object.keys(groups)) {
            const group = groups[k];
            if (group) {
                pass.setBindGroup(this.descriptor.bindGroupLayouts[k].group, group.wrapped);
            }
        }
    }
}
export class ComputePipeline {
    constructor(layout, module, entryPoint) {
        this.layout = layout;
        this.module = module;
        this.entryPoint = entryPoint;
        this.descriptor = {
            label: `${layout.label}/${module.descriptor.label}/${entryPoint}`,
            layout: layout.wrapped,
            compute: {
                entryPoint,
                module: module.shaderModule,
            }
        };
        this.wrapped = layout.device.wrapped.createComputePipeline(this.descriptor);
    }
    addTo(pass, groups = {}) {
        pass.setPipeline(this.wrapped);
        this.addGroupsTo(pass, groups);
    }
    addGroupsTo(pass, groups) {
        this.layout.addTo(pass, groups);
    }
}
export function group(group, layout) {
    return { group, layout };
}
