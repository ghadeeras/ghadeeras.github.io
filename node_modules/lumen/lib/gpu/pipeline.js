import { label } from "./utils.js";
export class PipelineLayout {
    constructor(device, label, descriptor) {
        this.device = device;
        this.label = label;
        this.descriptor = descriptor;
        const groups = Object.values(descriptor).map(g => g.group);
        const count = groups.length > 0 ? 1 + Math.max(...groups) : 0;
        const bindGroupLayouts = new Array(count);
        for (const k of Object.keys(descriptor)) {
            const entry = descriptor[k];
            bindGroupLayouts[entry.group] = entry.layout.wrapped;
        }
        this.wrapped = device.wrapped.createPipelineLayout({ label, bindGroupLayouts });
    }
    computePipeline(module, entryPoint) {
        return new ComputePipeline(this, module, entryPoint);
    }
    addTo(pass, groups) {
        for (const k of Object.keys(groups)) {
            const group = groups[k];
            if (group) {
                pass.setBindGroup(this.descriptor[k].group, group.wrapped);
            }
        }
    }
    static instances(device, descriptors, labelPrefix) {
        const result = {};
        for (const key in descriptors) {
            result[key] = PipelineLayout.instance(device, descriptors[key], label(labelPrefix, key));
        }
        return result;
    }
    static instance(device, descriptor, label) {
        return new PipelineLayout(device, label ?? PipelineLayout.labelFrom(descriptor), descriptor);
    }
    static labelFrom(descriptor) {
        return `[ ${Object.keys(descriptor)
            .sort((a, b) => descriptor[a].group - descriptor[b].group)
            .map(key => `${key}: ${descriptor[key].layout.label}`)
            .join(", ")} ]`;
    }
}
export class ComputePipeline {
    constructor(layout, module, entryPoint) {
        this.layout = layout;
        this.module = module;
        this.entryPoint = entryPoint;
        this.descriptor = {
            label: label(layout.label, module.descriptor.label, entryPoint),
            layout: layout.wrapped,
            compute: {
                entryPoint,
                module: module.shaderModule,
            }
        };
        this.wrapped = layout.device.wrapped.createComputePipeline(this.descriptor);
    }
    addTo(pass, groups = {}) {
        pass.setPipeline(this.wrapped);
        this.addGroupsTo(pass, groups);
    }
    addGroupsTo(pass, groups) {
        this.layout.addTo(pass, groups);
    }
}
export function group(group, layout) {
    return { group, layout };
}
