import * as utl from "./utils.js";
import { ComputePassBuilder } from "./index.js";
export class PipelineLayout {
    constructor(device, label, descriptor) {
        this.device = device;
        this.label = label;
        this.descriptor = descriptor;
        const groups = Object.values(descriptor).map(g => g.group);
        const count = groups.length > 0 ? 1 + Math.max(...groups) : 0;
        const bindGroupLayouts = new Array(count);
        for (const k of Object.keys(descriptor)) {
            const entry = descriptor[k];
            bindGroupLayouts[entry.group] = entry.layout.wrapped;
        }
        this.wrapped = device.wrapped.createPipelineLayout({ label, bindGroupLayouts });
    }
    async computePipeline(compute, label) {
        return await ComputePipeline.instance({ label, layout: this, compute });
    }
    bindGroups(name, groups) {
        return this.descriptor[name].layout.bindGroups(groups);
    }
    bindGroup(name, group) {
        return this.descriptor[name].layout.bindGroup(group);
    }
    addTo(pass, groups) {
        for (const k of Object.keys(groups)) {
            const group = groups[k];
            if (group) {
                pass.setBindGroup(this.descriptor[k].group, group.wrapped);
            }
        }
    }
    static instances(device, descriptors, labelPrefix) {
        const result = {};
        for (const key in descriptors) {
            result[key] = PipelineLayout.instance(device, descriptors[key], utl.label(labelPrefix, key));
        }
        return result;
    }
    static instance(device, descriptor, label) {
        return new PipelineLayout(device, label ?? PipelineLayout.labelFrom(descriptor), descriptor);
    }
    static labelFrom(descriptor) {
        return `[ ${Object.keys(descriptor)
            .sort((a, b) => descriptor[a].group - descriptor[b].group)
            .map(key => `${key}: ${descriptor[key].layout.label}`)
            .join(", ")} ]`;
    }
}
export class ComputePipeline {
    constructor(wrapped, descriptor) {
        this.wrapped = wrapped;
        this.descriptor = descriptor;
        this._label = descriptor.label ?? "compute pipeline";
    }
    get label() {
        return this._label;
    }
    get layout() {
        return this.descriptor.layout;
    }
    bindGroups(name, groups) {
        return this.layout.bindGroups(name, groups);
    }
    bindGroup(name, group) {
        return this.layout.bindGroup(name, group);
    }
    addTo(pass, groups = {}) {
        pass.setPipeline(this.wrapped);
        this.addGroupsTo(pass, groups);
        return pass;
    }
    addGroupsTo(pass, groups) {
        this.layout.addTo(pass, groups);
    }
    withGroups(groups) {
        return new ComputePassBuilder(this, groups);
    }
    static async instance(descriptor) {
        const gpuDescriptor = utl.withLabel({
            label: descriptor.label,
            layout: descriptor.layout.wrapped,
            compute: {
                entryPoint: descriptor.compute.entryPoint,
                module: descriptor.compute.module.wrapped,
            }
        }, descriptor.layout.label, descriptor.compute.module.label, descriptor.compute.entryPoint);
        const wrapped = await descriptor.layout.device.wrapped.createComputePipelineAsync(gpuDescriptor);
        return new ComputePipeline(wrapped, descriptor);
    }
}
export function group(group, layout) {
    return { group, layout };
}
