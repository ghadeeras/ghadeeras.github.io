import { Only } from "../utils.js";
import { Device } from "./device.js";
import { TextureFormatSource } from "./utils.js";
export type ShaderModules<D extends ShaderModuleDescriptors> = {
    [k in keyof D]: ShaderModule;
};
export type ShaderModuleDescriptors = Record<string, ShaderModuleDescriptor>;
export type ShaderModuleDescriptor = ShaderModuleCode & {
    label?: string;
    compilationHints?: Array<GPUShaderModuleCompilationHint>;
    templateFunction?: (code: string) => string;
};
export type ShaderModuleCode = Only<ShaderModuleCodeAttributes, "path"> | Only<ShaderModuleCodeAttributes, "code">;
type ShaderModuleCodeAttributes = {
    path: string;
    code: string;
};
export declare class ShaderModule {
    readonly device: Device;
    readonly shaderModule: GPUShaderModule;
    readonly descriptor: Readonly<GPUShaderModuleDescriptor>;
    constructor(label: string, device: Device, code: string);
    hasCompilationErrors(): Promise<boolean>;
    computePipeline(entryPoint: string, layout?: GPUPipelineLayout | "auto"): GPUComputePipeline;
    vertexState(entryPoint: string, buffers: (GPUVertexBufferLayout | number)[]): GPUVertexState;
    fragmentState(entryPoint: string, targets: (TextureFormatSource | null)[]): GPUFragmentState;
}
export declare const renderingShaders: {
    fullScreenPassVertex: (fragmentShader: string) => string;
    fullScreenPass: (shader: string) => string;
};
export {};
