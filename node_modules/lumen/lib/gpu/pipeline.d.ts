import { Device } from "./device.js";
import { BindGroup, BindGroupLayout, BindGroupLayoutDescriptor } from "./group.js";
import { ShaderModule } from "./shader.js";
export type PipelineEntries<D extends PipelineLayoutDescriptor> = {
    [k in keyof D["bindGroupLayouts"]]: D["bindGroupLayouts"][k]["layout"] extends BindGroupLayout<infer L> ? BindGroup<L> : never;
};
export type PipelineLayouts<D extends PipelineLayoutDescriptors> = {
    [k in keyof D]: PipelineLayout<D[k]>;
};
export type PipelineLayoutDescriptors = Record<string, PipelineLayoutDescriptor>;
export type PipelineLayoutDescriptor = {
    bindGroupLayouts: Record<string, PipelineLayoutEntry<BindGroupLayoutDescriptor>>;
};
export type PipelineLayoutEntry<L extends BindGroupLayoutDescriptor> = {
    group: number;
    layout: BindGroupLayout<L>;
};
export declare class PipelineLayout<D extends PipelineLayoutDescriptor> {
    readonly device: Device;
    readonly label: string;
    readonly descriptor: D;
    readonly wrapped: GPUPipelineLayout;
    constructor(device: Device, label: string, descriptor: D);
    computeInstance(module: ShaderModule, entryPoint: string): ComputePipeline<D>;
    addTo(pass: GPUBindingCommandsMixin, groups: Partial<PipelineEntries<D>>): void;
}
export declare class ComputePipeline<D extends PipelineLayoutDescriptor> {
    readonly layout: PipelineLayout<D>;
    readonly module: ShaderModule;
    readonly entryPoint: string;
    readonly wrapped: GPUComputePipeline;
    readonly descriptor: GPUComputePipelineDescriptor;
    constructor(layout: PipelineLayout<D>, module: ShaderModule, entryPoint: string);
    addTo(pass: GPUComputePassEncoder, groups?: Partial<PipelineEntries<D>>): void;
    addGroupsTo(pass: GPUBindingCommandsMixin, groups: Partial<PipelineEntries<D>>): void;
}
export declare function group<D extends BindGroupLayoutDescriptor>(group: number, layout: BindGroupLayout<D>): PipelineLayoutEntry<D>;
