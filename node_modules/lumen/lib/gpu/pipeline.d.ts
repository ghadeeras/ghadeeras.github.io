import { Device } from "./device.js";
import { BindGroup, BindGroupLayout } from "./group.js";
import { Definition, GPUObject } from "./meta.js";
import { ShaderModule } from "./shader.js";
export type PipelineLayoutDescriptor = {
    bindGroupLayouts: PipelineLayoutEntries;
};
export type PipelineLayoutEntries = Record<string, PipelineLayoutEntry<any>>;
export type PipelineLayoutEntry<L extends BindGroupLayout<any>> = {
    group: number;
    layout: Definition<L>;
};
export type PipelineEntries<L extends PipelineLayoutEntries> = {
    [k in keyof L]: L[k] extends PipelineLayoutEntry<BindGroupLayout<infer T>> ? BindGroup<T> : never;
};
export declare class PipelineLayout<L extends PipelineLayoutEntries> extends GPUObject {
    readonly device: Device;
    readonly entries: PipelineLayoutEntries;
    readonly wrapped: GPUPipelineLayout;
    readonly descriptor: GPUPipelineLayoutDescriptor;
    constructor(label: string, device: Device, entries: PipelineLayoutEntries, bindGroupLayouts: GPUBindGroupLayout[]);
    static from<D extends PipelineLayoutDescriptor>(descriptor: D): Definition<PipelineLayout<D["bindGroupLayouts"]>>;
    static create<D extends PipelineLayoutDescriptor>(device: Device, label: string, descriptor: D): Promise<PipelineLayout<D["bindGroupLayouts"]>>;
    computeInstance(module: ShaderModule, entryPoint: string): ComputePipeline<L>;
}
export declare class ComputePipeline<L extends PipelineLayoutEntries> {
    readonly layout: PipelineLayout<L>;
    readonly module: ShaderModule;
    readonly entryPoint: string;
    readonly wrapped: GPUComputePipeline;
    readonly descriptor: GPUComputePipelineDescriptor;
    constructor(layout: PipelineLayout<L>, module: ShaderModule, entryPoint: string);
    addTo(pass: GPUComputePassEncoder, groups?: Partial<PipelineEntries<L>>): void;
    addGroupsTo(pass: GPUComputePassEncoder, groups: Partial<PipelineEntries<L>>): void;
}
export declare function group<L extends BindGroupLayout<any>>(group: number, layout: Definition<L>): PipelineLayoutEntry<L>;
