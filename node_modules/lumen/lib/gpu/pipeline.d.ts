import * as grp from "./group.js";
import * as utl from "./utils.js";
import { Device } from "./device.js";
import { ShaderModule } from "./shader.js";
import { ComputePassBuilder } from "./index.js";
export type CompatiblePipelineEntries<L extends PipelineLayout> = PipelineEntries<InferPipelineLayoutDescriptor<L>>;
export type InferPipelineLayoutDescriptor<L extends PipelineLayout> = L extends PipelineLayout<infer D> ? D : never;
export type PipelineLayouts<D extends PipelineLayoutDescriptors> = {
    [k in keyof D]: PipelineLayout<D[k]>;
};
export declare class PipelineLayout<D extends PipelineLayoutDescriptor = {}> {
    readonly device: Device;
    readonly label: string;
    readonly descriptor: D;
    readonly wrapped: GPUPipelineLayout;
    private constructor();
    computePipeline(compute: ProgrammableStage, label?: string): Promise<ComputePipeline<D>>;
    bindGroups<G extends keyof D>(name: G, groups: grp.CompatibleBindGroupDescriptors<D[G]["layout"]>): grp.BindGroups<grp.BindGroupLayoutDescriptor, grp.CompatibleBindGroupDescriptors<D[G]["layout"]>>;
    bindGroup<G extends keyof D>(name: G, group: grp.CompatibleBindGroupDescriptor<D[G]["layout"]>): grp.BindGroup<grp.BindGroupLayoutDescriptor>;
    addTo(pass: GPUBindingCommandsMixin, groups: PipelineEntries<D>): void;
    static instances<D extends PipelineLayoutDescriptors>(device: Device, descriptors: D, labelPrefix?: string): PipelineLayouts<D>;
    static instance<D extends PipelineLayoutDescriptor>(device: Device, descriptor: D, label?: string): PipelineLayout<D>;
    static labelFrom<D extends PipelineLayoutDescriptor>(descriptor: D): string;
}
export type PipelineLayoutDescriptors = Record<string, PipelineLayoutDescriptor>;
export type PipelineLayoutDescriptor = Record<string, PipelineLayoutEntry<grp.BindGroupLayoutDescriptor>>;
export type PipelineLayoutEntry<L extends grp.BindGroupLayoutDescriptor> = {
    group: number;
    layout: grp.BindGroupLayout<L>;
};
export type PipelineEntries<D extends PipelineLayoutDescriptor> = Partial<{
    [k in keyof D]: D[k]["layout"] extends grp.BindGroupLayout<infer L> ? grp.BindGroup<L> : never;
}>;
export declare class ComputePipeline<D extends PipelineLayoutDescriptor> {
    readonly wrapped: GPUComputePipeline;
    readonly descriptor: ComputePipelineDescriptor<D>;
    private _label;
    constructor(wrapped: GPUComputePipeline, descriptor: ComputePipelineDescriptor<D>);
    get label(): string;
    get layout(): PipelineLayout<D>;
    bindGroups<G extends keyof D>(name: G, groups: grp.CompatibleBindGroupDescriptors<D[G]["layout"]>): grp.BindGroups<grp.BindGroupLayoutDescriptor, grp.CompatibleBindGroupDescriptors<D[G]["layout"]>>;
    bindGroup<G extends keyof D>(name: G, group: grp.CompatibleBindGroupDescriptor<D[G]["layout"]>): grp.BindGroup<grp.BindGroupLayoutDescriptor>;
    addTo(pass: GPUComputePassEncoder, groups?: PipelineEntries<D>): GPUComputePassEncoder;
    addGroupsTo(pass: GPUBindingCommandsMixin, groups: PipelineEntries<D>): void;
    withGroups(groups: PipelineEntries<D>): ComputePassBuilder<D>;
    static instance<D extends PipelineLayoutDescriptor>(descriptor: ComputePipelineDescriptor<D>): Promise<ComputePipeline<D>>;
}
export type ComputePipelineDescriptor<D extends PipelineLayoutDescriptor> = {
    layout: PipelineLayout<D>;
    label?: string | undefined;
    compute: ProgrammableStage;
};
export type ProgrammableStage = utl.Redefine<GPUProgrammableStage, "module", ShaderModule>;
export declare function group<D extends grp.BindGroupLayoutDescriptor>(group: number, layout: grp.BindGroupLayout<D>): PipelineLayoutEntry<D>;
