export interface Element<T> {
    alignment: number;
    size: number;
    paddedSize: number;
    offset: number;
    stride: number;
    packed: boolean;
    view(dataOrSize?: T[] | number): DataView;
    range(index?: number, count?: number): [number, number];
    read(view: DataView): T;
    write(view: DataView, value: T): void;
    readOne(view: DataView, index: number): T;
    writeOne(view: DataView, index: number, value: T): void;
    readMulti(view: DataView, index: number, count: number): T[];
    writeMulti(view: DataView, index: number, values: T[]): void;
    clone(offset: number, stride: number, packed: boolean): Element<T>;
    times(length: number): StaticArray<T, this>;
}
export type DataTypeOf<T extends Element<any>> = T extends Element<infer V> ? V : never;
export type StructTypeOf<T extends Record<string, Element<any>>> = {
    [K in keyof T]: DataTypeOf<T[K]>;
};
export type VertexStructTypeOf<T extends Record<string, Element<any>>> = {
    [K in keyof T]: DataTypeOf<T[K]>;
};
declare abstract class BaseElement<T> implements Element<T> {
    readonly alignment: number;
    readonly size: number;
    readonly paddedSize: number;
    readonly offset: number;
    readonly stride: number;
    readonly packed: boolean;
    constructor(alignment: number, size: number, offset: number, stride: number, packed: boolean);
    view(dataOrSize?: T[] | number): DataView;
    range(index?: number, count?: number): [number, number];
    read(view: DataView): T;
    write(view: DataView, value: T): void;
    readMulti(view: DataView, index: number, count: number): T[];
    writeMulti(view: DataView, index: number, values: T[]): void;
    times(length: number): StaticArray<T, this>;
    abstract readOne(view: DataView, index: number): T;
    abstract writeOne(view: DataView, index: number, value: T): void;
    abstract clone(offset: number, stride: number, packed: boolean): Element<T>;
}
export declare abstract class VertexElement<T> extends BaseElement<T> {
    readonly format: GPUVertexFormat;
    constructor(format: GPUVertexFormat, alignment: number, size: number, offset: number, stride: number, packed: boolean);
    atLocation(location: number): GPUVertexAttribute;
}
declare abstract class Primitive32 extends VertexElement<number> {
    private getter;
    private setter;
    constructor(format: GPUVertexFormat, offset: number, stride: number, packed: boolean, getter: (view: DataView, offset: number) => number, setter: (view: DataView, offset: number, value: number) => void);
    readOne(view: DataView, index: number): number;
    writeOne(view: DataView, index: number, value: number): void;
    abstract clone(offset: number, stride: number, packed: boolean): Primitive32;
    get x2(): Vec2<this>;
    get x3(): Vec3<this>;
    get x4(): Vec4<this>;
}
export declare class U32 extends Primitive32 {
    constructor(offset: number, stride: number, packed: boolean);
    clone(offset: number, stride: number, packed: boolean): U32;
}
export declare class I32 extends Primitive32 {
    constructor(offset: number, stride: number, packed: boolean);
    clone(offset: number, stride: number, packed: boolean): I32;
}
export declare class F32 extends Primitive32 {
    constructor(offset: number, stride: number, packed: boolean);
    clone(offset: number, stride: number, packed: boolean): F32;
}
export declare abstract class VecN<C extends number[]> extends VertexElement<C> {
    constructor(format: GPUVertexFormat, alignment: number, size: number, offset: number, stride: number, packed: boolean);
    get x2(): Mat2<C, this>;
    get x3(): Mat3<C, this>;
    get x4(): Mat4<C, this>;
}
export declare class Vec2<T extends Primitive32> extends VecN<[number, number]> {
    readonly component: T;
    readonly x: T;
    readonly y: T;
    constructor(component: T, offset: number, stride: number, packed: boolean);
    readOne(view: DataView, index: number): [number, number];
    writeOne(view: DataView, index: number, value: [number, number]): void;
    clone(offset: number, stride: number, packed: boolean): Vec2<T>;
}
export declare class Vec3<T extends Primitive32> extends VecN<[number, number, number]> {
    readonly component: T;
    readonly x: T;
    readonly y: T;
    readonly z: T;
    constructor(component: T, offset: number, stride: number, packed: boolean);
    readOne(view: DataView, index: number): [number, number, number];
    writeOne(view: DataView, index: number, value: [number, number, number]): void;
    clone(offset: number, stride: number, packed: boolean): Vec3<T>;
}
export declare class Vec4<T extends Primitive32> extends VecN<[number, number, number, number]> {
    readonly component: T;
    readonly x: T;
    readonly y: T;
    readonly z: T;
    readonly w: T;
    constructor(component: T, offset: number, stride: number, packed: boolean);
    readOne(view: DataView, index: number): [number, number, number, number];
    writeOne(view: DataView, index: number, value: [number, number, number, number]): void;
    clone(offset: number, stride: number, packed: boolean): Vec4<T>;
}
export declare class Mat2<T, V extends Element<T>> extends BaseElement<[T, T]> {
    readonly component: V;
    readonly x: V;
    readonly y: V;
    constructor(component: V, offset: number, stride: number, packed: boolean);
    readOne(view: DataView, index: number): [T, T];
    writeOne(view: DataView, index: number, value: [T, T]): void;
    clone(offset: number, stride: number, packed: boolean): Mat2<T, V>;
}
export declare class Mat3<T, V extends Element<T>> extends BaseElement<[T, T, T]> {
    readonly component: V;
    readonly x: V;
    readonly y: V;
    readonly z: V;
    constructor(component: V, offset: number, stride: number, packed: boolean);
    readOne(view: DataView, index: number): [T, T, T];
    writeOne(view: DataView, index: number, value: [T, T, T]): void;
    clone(offset: number, stride: number, packed: boolean): Mat3<T, V>;
}
export declare class Mat4<T, V extends BaseElement<T>> extends BaseElement<[T, T, T, T]> {
    readonly component: V;
    readonly x: V;
    readonly y: V;
    readonly z: V;
    readonly w: V;
    constructor(component: V, offset: number, stride: number, packed: boolean);
    readOne(view: DataView, index: number): [T, T, T, T];
    writeOne(view: DataView, index: number, value: [T, T, T, T]): void;
    clone(offset: number, stride: number, packed: boolean): Mat4<T, V>;
}
export declare class StaticArray<T, I extends Element<T>> extends BaseElement<T[]> {
    readonly item: I;
    readonly items: I[];
    constructor(item: I, length: number, offset: number, stride: number, packed: boolean);
    readOne(view: DataView, index: number): T[];
    writeOne(view: DataView, index: number, value: T[]): void;
    clone(offset: number, stride: number, packed: boolean): StaticArray<T, I>;
}
export declare class Struct<T extends Record<string, Element<any>>> extends BaseElement<StructTypeOf<T>> {
    readonly membersOrder: (keyof T)[];
    readonly members: T;
    constructor(membersOrder: (keyof T)[], members: T, offset: number, stride: number, packed: boolean);
    writeOne(view: DataView, index: number, value: StructTypeOf<T>): void;
    readOne(view: DataView, index: number): StructTypeOf<T>;
    clone(offset: number, stride: number, packed: boolean): Struct<T>;
    asVertex(attributes?: (keyof T)[]): Vertex<T>;
}
export declare class Vertex<T extends Record<string, Element<any>>> {
    readonly attributes: (keyof T)[];
    readonly struct: Struct<T>;
    constructor(attributes: (keyof T)[], struct: Struct<T>);
    asBufferLayout(stepMode?: GPUVertexStepMode, baseIndex?: number): GPUVertexBufferLayout;
    sub(attributes?: (keyof T)[]): Vertex<T>;
}
export declare const u32: U32;
export declare const i32: I32;
export declare const f32: F32;
export declare function vec2<T extends Primitive32>(component: T): Vec2<T>;
export declare function vec3<T extends Primitive32>(component: T): Vec3<T>;
export declare function vec4<T extends Primitive32>(component: T): Vec4<T>;
export declare const mat2x2: Mat2<[number, number], Vec2<F32>>;
export declare const mat2x3: Mat2<[number, number, number], Vec3<F32>>;
export declare const mat2x4: Mat2<[number, number, number, number], Vec4<F32>>;
export declare const mat3x2: Mat3<[number, number], Vec2<F32>>;
export declare const mat3x3: Mat3<[number, number, number], Vec3<F32>>;
export declare const mat3x4: Mat3<[number, number, number, number], Vec4<F32>>;
export declare const mat4x2: Mat4<[number, number], Vec2<F32>>;
export declare const mat4x3: Mat4<[number, number, number], Vec3<F32>>;
export declare const mat4x4: Mat4<[number, number, number, number], Vec4<F32>>;
export declare function struct<T extends Record<string, Element<any>>>(members: T, membersOrder?: (keyof T)[]): Struct<T>;
export declare function packed<T extends Record<string, VertexElement<any>>>(membersOrder: (keyof T)[], members: T): Struct<T>;
export declare function vertex<T extends Record<string, VertexElement<any>>>(members: T, membersOrder?: (keyof T)[]): Vertex<T>;
export {};
