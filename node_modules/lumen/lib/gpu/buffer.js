export class SyncBuffer {
    constructor(gpuBuffer, cpuBuffer) {
        this.gpuBuffer = gpuBuffer;
        this.cpuBuffer = cpuBuffer;
        this.dirtyRange = [cpuBuffer.byteLength, 0];
    }
    asBindingResource(binding = {}) {
        return this.gpuBuffer.asBindingResource(binding);
    }
    get(element) {
        return element.read(this.cpuBuffer);
    }
    set(element, value) {
        element.write(this.cpuBuffer, value);
        this.dirty(element.range());
    }
    dirty(range) {
        if (this.dirtyRange[0] > this.dirtyRange[1]) {
            setTimeout(() => this.clean());
        }
        if (range[0] < this.dirtyRange[0]) {
            this.dirtyRange[0] = range[0];
        }
        if (range[1] > this.dirtyRange[1]) {
            this.dirtyRange[1] = range[1];
        }
    }
    clean() {
        const offset = this.dirtyRange[0];
        const size = this.dirtyRange[1] - this.dirtyRange[0];
        this.gpuBuffer.set({ offset, size }).fromData(this.cpuBuffer, offset);
        this.dirtyRange[0] = this.cpuBuffer.byteLength;
        this.dirtyRange[1] = 0;
    }
    static create(device, descriptor) {
        const gpuBuffer = new DataBuffer(device, descriptor);
        const cpuBuffer = descriptor.data === undefined ? new DataView(new ArrayBuffer(gpuBuffer.size)) : descriptor.data;
        return new SyncBuffer(gpuBuffer, cpuBuffer);
    }
}
export class AbstractBuffer {
    constructor(_device, _wrapped) {
        this._device = _device;
        this._wrapped = _wrapped;
    }
    get wrapped() {
        return this._wrapped;
    }
    set wrapped(b) {
        this._wrapped.destroy();
        this._wrapped = b;
    }
    get size() {
        return this._wrapped.size;
    }
    get label() {
        return this._wrapped.label;
    }
    get device() {
        return this._device;
    }
    destroy() {
        this._wrapped.destroy();
    }
    asBindingResource(binding = null) {
        return binding === null ? this._wrapped : {
            ...binding,
            buffer: this._wrapped,
        };
    }
}
export class DataBuffer extends AbstractBuffer {
    constructor(device, descriptor) {
        super(device, descriptor.size !== undefined ?
            newBlankBuffer(device, usageFlags(descriptor), descriptor.size, descriptor.label) :
            newInitializedBuffer(device, usageFlags(descriptor), descriptor.data, descriptor.label));
        this.descriptor = descriptor;
        this.descriptor = descriptor;
    }
    copy(segment = {}) {
        return {
            ...copy(segment.size).from(this, segment.offset),
            ...copy(segment.size).to(this, segment.offset),
        };
    }
    async setData(data) {
        if (data.byteLength > this.size) {
            this.wrapped = newInitializedBuffer(this.device, usageFlags(this.descriptor), data, this.label);
        }
        else {
            this.set({ offset: 0, size: data.byteLength }).fromData(data);
        }
    }
    set(bufferSegment = {}) {
        return {
            fromData: async (data, dataOffset = 0) => {
                const bufferOffset = bufferSegment.offset ?? 0;
                const size = bufferSegment.size ?? Math.min(this.size - bufferOffset, data.byteLength - dataOffset);
                const absoluteDataOffset = data.byteOffset + dataOffset;
                const validBufferOffset = lowerMultipleOf(4, bufferOffset);
                const offsetCorrection = bufferOffset - validBufferOffset;
                const validDataOffset = absoluteDataOffset - offsetCorrection;
                const validSize = upperMultipleOf(4, size + offsetCorrection);
                this.device.wrapped.queue.writeBuffer(this.wrapped, validBufferOffset, data.buffer, validDataOffset, validSize);
            }
        };
    }
    get(bufferSegment = {}) {
        return {
            asData: (data, dataOffset = 0) => {
                const dataSize = data?.byteLength ?? this.size;
                const bufferOffset = bufferSegment.offset ?? 0;
                const size = bufferSegment.size ?? Math.min(this.size - bufferOffset, dataSize - dataOffset);
                const temp = this.device.readBuffer(size, `${this.label}-temp`);
                try {
                    this.copy(bufferSegment).to(temp);
                    return temp.get().asData(data, dataOffset);
                }
                finally {
                    temp.destroy();
                }
            }
        };
    }
}
export class ReadBuffer extends AbstractBuffer {
    constructor(device, size, label) {
        super(device, newBlankBuffer(device, GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST, size, label));
        this.mapper = new BufferMapper(this.wrapped, GPUMapMode.READ);
    }
    copy(bufferSegment = {}) {
        return copy(bufferSegment.size).to(this, bufferSegment.offset);
    }
    get(bufferSegment = {}) {
        return {
            asData: async (data, dataOffset = 0) => {
                const bufferOffset = bufferSegment.offset ?? 0;
                const dataView = data ?? new DataView(new ArrayBuffer(bufferSegment.size ?? this.size - bufferOffset));
                const size = bufferSegment.size ?? Math.min(this.size - bufferOffset, dataView.byteLength - dataOffset);
                const src = await this.mapper.mapAsync(bufferOffset, size);
                const dst = new Uint8Array(dataView.buffer, dataView.byteOffset + dataOffset, size);
                dst.set(src);
                return dataView;
            },
        };
    }
}
export class WriteBuffer extends AbstractBuffer {
    constructor(device, data, label) {
        super(device, newInitializedBuffer(device, GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC, data, label));
        this.data = data;
        this.data = data;
        this.mapper = new BufferMapper(this.wrapped, GPUMapMode.WRITE);
    }
    copy(bufferSegment = {}) {
        return copy(bufferSegment.size).from(this, bufferSegment.offset);
    }
    set(bufferSegment = {}) {
        return {
            fromData: async (data, dataOffset = 0) => {
                const bufferOffset = bufferSegment.offset ?? 0;
                const size = bufferSegment.size ?? Math.min(this.size - bufferOffset, data.byteLength - dataOffset);
                const dst = await this.mapper.mapAsync(bufferOffset, size);
                const src = new Uint8Array(data.buffer, data.byteOffset + dataOffset, size);
                dst.set(src);
            }
        };
    }
}
export function copy(segmentSize) {
    return {
        from: (srcBuffer, srcOffset = 0) => ({
            to: (dstBuffer, dstOffset = 0) => {
                const size = segmentSize ?? Math.min(srcBuffer.size - srcOffset, dstBuffer.size - dstOffset);
                const srcValidOffset = lowerMultipleOf(4, srcOffset);
                const dstValidOffset = lowerMultipleOf(4, dstOffset);
                const srcOffsetCorrection = srcOffset - srcValidOffset;
                const dstOffsetCorrection = dstOffset - dstValidOffset;
                if (srcOffsetCorrection !== dstOffsetCorrection) {
                    throw new Error("Copying between unaligned buffers is not possible!");
                }
                const validSize = upperMultipleOf(4, size + srcOffsetCorrection);
                srcBuffer.device.enqueueCommands(`copy-${srcBuffer.label}-to-${dstBuffer.label}`, encoder => {
                    encoder.encoder.copyBufferToBuffer(srcBuffer.wrapped, srcValidOffset, dstBuffer.wrapped, dstValidOffset, validSize);
                });
            }
        }),
        to: (dstBuffer, dstOffset = 0) => ({
            from: (srcBuffer, srcOffset = 0) => {
                copy(segmentSize).from(srcBuffer, srcOffset).to(dstBuffer, dstOffset);
            }
        })
    };
}
class BufferMapper {
    constructor(buffer, mode) {
        this.buffer = buffer;
        this.mode = mode;
        this.range = [this.buffer.size, 0];
        this.promise = Promise.resolve();
    }
    request(offset, size, resolve, reject) {
        const mappingScheduled = this.range[1] > this.range[0];
        this.range = [Math.min(this.range[0], offset), Math.max(this.range[1], offset + size)];
        return (mappingScheduled ? this.promise : this.scheduleMapping()).then(resolve, e => {
            reject(e);
            return Promise.reject(e);
        });
    }
    scheduleMapping() {
        const callback = () => new Promise((resolve, reject) => {
            setTimeout(() => {
                this.buffer.mapAsync(this.mode, this.range[0], this.range[1] - this.range[0]).then(resolve, reject);
                this.range = [this.buffer.size, 0];
                this.promise = this.promise.finally(() => this.buffer.unmap());
            });
        });
        return this.promise = this.promise.then(callback, callback);
    }
    async mapAsync(offset, size) {
        const validOffset = lowerMultipleOf(8, offset);
        const offsetCorrection = offset - validOffset;
        const validSize = upperMultipleOf(4, size + offsetCorrection);
        return new Promise((resolve, reject) => this.request(validOffset, validSize, () => {
            const range = this.buffer.getMappedRange(validOffset, validSize);
            resolve(new Uint8Array(range.slice(), offsetCorrection, size));
        }, reject));
    }
}
function newBlankBuffer(device, usage, size, label) {
    return device.wrapped.createBuffer({
        size: upperMultipleOf(4, size),
        usage,
        label
    });
}
function newInitializedBuffer(device, usage, data, label) {
    const buffer = device.wrapped.createBuffer({
        mappedAtCreation: true,
        size: upperMultipleOf(4, data.byteLength),
        usage,
        label
    });
    const range = buffer.getMappedRange(0, buffer.size);
    const src = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
    const dst = new Uint8Array(range, 0, data.byteLength);
    dst.set(src);
    buffer.unmap();
    return buffer;
}
function usageFlags(descriptor) {
    return GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST | descriptor.usage
        .map(u => GPUBufferUsage[u])
        .reduce((u1, u2) => u1 | u2, 0);
}
function upperMultipleOf(n, value) {
    return Math.ceil(value / n) * n;
}
function lowerMultipleOf(n, value) {
    return Math.floor(value / n) * n;
}
