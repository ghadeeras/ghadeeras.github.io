import * as bfr from "./buffer.js";
import * as txr from "./texture.js";
import * as utl from "./utils.js";
import { Device } from "./device.js";
import { Element } from "./types.js";
import { PipelineLayoutEntry } from "./index.js";
export type CompatibleBindGroup<L extends BindGroupLayout> = BindGroup<InferBindGroupLayoutDescriptor<L>>;
export type CompatibleBindGroups<L extends BindGroupLayout> = BindGroups<InferBindGroupLayoutDescriptor<L>>;
export type CompatibleBindGroupDescriptor<L extends BindGroupLayout> = BindGroupDescriptor<InferBindGroupLayoutDescriptor<L>>;
export type CompatibleBindGroupDescriptors<L extends BindGroupLayout> = BindGroupDescriptors<InferBindGroupLayoutDescriptor<L>>;
export type InferBindGroupLayoutDescriptor<L extends BindGroupLayout> = L extends BindGroupLayout<infer D> ? D : never;
export type BindGroups<L extends BindGroupLayoutDescriptor = {}, G extends BindGroupDescriptors<L> = {}> = {
    [K in keyof G]: BindGroup<L>;
};
export declare class BindGroup<L extends BindGroupLayoutDescriptor = {}> {
    readonly layout: BindGroupLayout<L>;
    readonly label: string;
    readonly entries: BindGroupDescriptor<L>;
    readonly device: Device;
    readonly wrapped: GPUBindGroup;
    constructor(layout: BindGroupLayout<L>, label: string, entries: BindGroupDescriptor<L>);
}
export type BindGroupDescriptors<L extends BindGroupLayoutDescriptor = {}> = Record<string, BindGroupDescriptor<L>>;
export type BindGroupDescriptor<L extends BindGroupLayoutDescriptor = {}> = {
    [K in keyof L]: InferResourceFromBindGroupLayoutEntry<L[K]>;
};
export type InferResourceFromBindGroupLayoutEntry<T extends BindGroupLayoutEntry> = T extends BindGroupLayoutEntry<infer R> ? R : never;
export type BindGroupLayouts<D extends BindGroupLayoutDescriptors = {}> = {
    [K in keyof D]: BindGroupLayout<D[K]>;
};
export declare class BindGroupLayout<L extends BindGroupLayoutDescriptor = {}> {
    readonly device: Device;
    readonly label: string;
    readonly entries: L;
    readonly wrapped: GPUBindGroupLayout;
    constructor(device: Device, label: string, entries: L);
    asEntry(group: number): PipelineLayoutEntry<L>;
    bindGroups<G extends BindGroupDescriptors<L>>(descriptors: G, labelPrefix?: string): BindGroups<L, G>;
    bindGroup(entries: BindGroupDescriptor<L>, label?: string): BindGroup<L>;
    private labelFrom;
    static instances<D extends BindGroupLayoutDescriptors>(device: Device, descriptors: D, labelPrefix?: string): BindGroupLayouts<D>;
    static instance<D extends BindGroupLayoutDescriptor>(device: Device, entries: D, label?: string): BindGroupLayout<D>;
    private static labelFrom;
}
export type BindGroupLayoutDescriptors = Record<string, BindGroupLayoutDescriptor>;
export type BindGroupLayoutDescriptor = Record<string, BindGroupLayoutEntry>;
export declare class BindGroupLayoutEntry<R extends utl.Resource = utl.Resource> {
    readonly binding: number;
    readonly visibility: number;
    readonly resource: ResourceBindingLayout<R>;
    readonly wrapped: GPUBindGroupLayoutEntry;
    constructor(binding: number, visibility: number, resource: ResourceBindingLayout<R>);
}
export declare function uniform<T>(contentType: Element<T>, hasDynamicOffset?: boolean): BufferBindingLayout<T>;
export declare function storage<T>(accessMode: AccessMode, contentType: Element<T>, hasDynamicOffset?: boolean): BufferBindingLayout<T>;
export declare function texture_storage_1d(format: GPUTextureFormat, accessMode?: AccessMode): TextureStorageBindingLayout;
export declare function texture_storage_2d(format: GPUTextureFormat, accessMode?: AccessMode): TextureStorageBindingLayout;
export declare function texture_storage_2d_array(format: GPUTextureFormat, accessMode?: AccessMode): TextureStorageBindingLayout;
export declare function texture_storage_3d(format: GPUTextureFormat, accessMode?: AccessMode): TextureStorageBindingLayout;
export declare function texture_1d(sampleType: GPUTextureSampleType): TextureBindingLayout;
export declare function texture_2d(sampleType: GPUTextureSampleType): TextureBindingLayout;
export declare function texture_2d_array(sampleType: GPUTextureSampleType): TextureBindingLayout;
export declare function texture_cube(sampleType: GPUTextureSampleType): TextureBindingLayout;
export declare function texture_cube_array(sampleType: GPUTextureSampleType): TextureBindingLayout;
export declare function texture_3d(sampleType: GPUTextureSampleType): TextureBindingLayout;
export declare function texture_depth_2d(sampleType: GPUTextureSampleType): TextureBindingLayout;
export declare function texture_depth_2d_array(sampleType: GPUTextureSampleType): TextureBindingLayout;
export declare function texture_depth_cube(sampleType: GPUTextureSampleType): TextureBindingLayout;
export declare function texture_depth_cube_array(sampleType: GPUTextureSampleType): TextureBindingLayout;
export declare function texture_multisampled_2d(sampleType: GPUTextureSampleType): TextureBindingLayout;
export declare function texture_depth_multisampled_2d(sampleType: GPUTextureSampleType): TextureBindingLayout;
export declare function texture_external(sampleType: GPUTextureSampleType): TextureBindingLayout;
export declare function sampler(type?: "filtering" | "non-filtering"): SamplerBindingLayout;
export declare function sampler_comparison(): SamplerBindingLayout;
export type AccessMode = "read" | "write" | "read_write";
export declare abstract class ResourceBindingLayout<R extends utl.Resource = utl.Resource> {
    readonly wrapped: Omit<GPUBindGroupLayoutEntry, "binding" | "visibility">;
    constructor(wrapped: Omit<GPUBindGroupLayoutEntry, "binding" | "visibility">);
    asEntry(binding: number, stage: keyof typeof GPUShaderStage, ...otherStages: (keyof typeof GPUShaderStage)[]): BindGroupLayoutEntry<R>;
}
export declare class BufferBindingLayout<T> extends ResourceBindingLayout<bfr.DataBuffer | bfr.SyncBuffer> {
    readonly buffer: GPUBufferBindingLayout;
    readonly contentType: Element<T>;
    constructor(buffer: GPUBufferBindingLayout, contentType: Element<T>);
}
export declare class TextureStorageBindingLayout extends ResourceBindingLayout<txr.Texture | txr.TextureView> {
    readonly storageTexture: GPUStorageTextureBindingLayout;
    constructor(storageTexture: GPUStorageTextureBindingLayout);
}
export declare class TextureBindingLayout extends ResourceBindingLayout<txr.Texture | txr.TextureView> {
    readonly texture: GPUTextureBindingLayout;
    constructor(texture: GPUTextureBindingLayout);
}
export declare class SamplerBindingLayout extends ResourceBindingLayout<txr.Sampler> {
    readonly sampler: GPUSamplerBindingLayout;
    constructor(sampler: GPUSamplerBindingLayout);
}
