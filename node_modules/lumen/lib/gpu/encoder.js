export class CommandEncoder {
    constructor(label, device) {
        this.device = device;
        this.descriptor = { label };
        this.wrapped = this.device.wrapped.createCommandEncoder(this.descriptor);
    }
    finish() {
        return this.wrapped.finish();
    }
    computePass(passSetter) {
        const pass = this.wrapped.beginComputePass();
        try {
            return passSetter(pass);
        }
        finally {
            pass.end();
        }
    }
    renderPass(descriptor, passSetter) {
        const pass = this.wrapped.beginRenderPass(descriptor);
        try {
            return passSetter(pass);
        }
        finally {
            pass.end();
        }
    }
}
export class Pass {
    constructor(device, label) {
        this.device = device;
        this.label = label;
    }
    enqueue() {
        this.device.enqueue(this.commandBuffer());
    }
    commandBuffer() {
        return this.device.commandBuffer(`${this.label} encoder`, encoder => this.encode(encoder));
    }
    encode(encoder) {
        this.pass(`${this.label} pass`, encoder, pass => this.inlineIn(pass));
        return encoder;
    }
}
export class ComputePass extends Pass {
    constructor(device, label, encoding) {
        super(device, label);
        this.encoding = encoding;
    }
    pass(label, encoder, encoding) {
        encoder.computePass(encoding);
    }
    inlineIn(passEncoder) {
        this.encoding(passEncoder);
        return passEncoder;
    }
}
export class ComputePassBuilder {
    constructor(pipeline, groups) {
        this.pipeline = pipeline;
        this.groups = groups;
    }
    dispatchWorkGroups(workgroupCountX, workgroupCountY, workgroupCountZ) {
        return new ComputePass(this.pipeline.layout.device, this.pipeline.label, pass => this.init(pass)
            .dispatchWorkgroups(workgroupCountX, workgroupCountY, workgroupCountZ));
    }
    dispatchWorkGroupsIndirect(indirectBuffer, indirectOffset) {
        return new ComputePass(this.pipeline.layout.device, this.pipeline.label, pass => this.init(pass)
            .dispatchWorkgroupsIndirect(indirectBuffer, indirectOffset));
    }
    init(pass) {
        return this.pipeline.addTo(pass, this.groups);
    }
}
