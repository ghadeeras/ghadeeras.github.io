import { formatOf } from "./utils.js";
export class Texture {
    constructor(device, descriptor) {
        this.device = device;
        this.descriptor = descriptor;
        this._wrapped = this.device.wrapped.createTexture(descriptor);
    }
    asBindingResource() {
        return this._wrapped;
    }
    get wrapped() {
        return this._wrapped;
    }
    get label() {
        return this._wrapped.label;
    }
    get size() {
        return this._wrapped;
    }
    set size(size) {
        this.descriptor.size = size;
        this._wrapped.destroy();
        this._wrapped = this.device.wrapped.createTexture(this.descriptor);
    }
    isAnyOf(...flags) {
        return flags.reduce((b, f) => b || (this.descriptor.usage & GPUTextureUsage[f]) !== 0, false);
    }
    isAllOf(...flags) {
        return flags.reduce((b, f) => b && (this.descriptor.usage & GPUTextureUsage[f]) !== 0, true);
    }
    destroy() {
        this._wrapped.destroy();
    }
    createView(descriptor = undefined) {
        return new TextureView(this, descriptor);
    }
    depthState(state = {}) {
        return {
            ...state,
            format: state.format ?? formatOf(this.descriptor.format),
            depthCompare: state.depthCompare ?? "less",
            depthWriteEnabled: state.depthWriteEnabled ?? true
        };
    }
    asColorTargetState(state = {}) {
        return {
            ...state,
            format: this.descriptor.format
        };
    }
    async generateMipmaps() {
        if (this._wrapped.mipLevelCount == 1) {
            return;
        }
        switch (this._wrapped.dimension) {
            case "2d": return await this.generate2DMipmaps();
            default: throw "Unsupported dimension: " + this._wrapped.dimension;
        }
    }
    async generate2DMipmaps() {
        const code = /*wgsl*/ `

            struct Vertex {
                @builtin(position) position: vec4<f32>,
                @location(0) clipPosition: vec2<f32>,
            };
            
            const triangle: array<vec2<f32>, 3> = array<vec2<f32>, 3>(
                vec2(-1.0, -1.0),
                vec2( 3.0, -1.0),
                vec2(-1.0,  3.0),
            );
            
            @vertex
            fn v_main(@builtin(vertex_index) i: u32) -> Vertex {
                let clipPosition: vec2<f32> = triangle[i];
                return Vertex(vec4<f32>(clipPosition, 0.0, 1.0), clipPosition);
            }

            @group(0) @binding(0)
            var src_level: texture_2d<f32>;

            @group(0) @binding(1)
            var texture_sampler: sampler;

            @fragment
            fn f_main(vertex: Vertex) -> @location(0) vec4<f32> {
                let uv = vec2(0.5, -0.5) * (vertex.clipPosition + vec2(1.0, -1.0));
                return textureSample(src_level, texture_sampler, uv);
            }
        `;
        const shader = await this.device.shaderModule({ label: "mipmap shader", code });
        const pipeline = await this.device.wrapped.createRenderPipelineAsync({
            label: "mipmap pipeline",
            layout: "auto",
            vertex: { module: shader.shaderModule },
            fragment: {
                module: shader.shaderModule,
                targets: [{
                        format: this._wrapped.format
                    }]
            }
        });
        const sampler = this.device.sampler({
            label: "mipmap sampler",
            minFilter: "linear",
            addressModeU: "clamp-to-edge",
            addressModeV: "clamp-to-edge",
        });
        for (let layer = 0; layer < this._wrapped.depthOrArrayLayers; layer++) {
            const l = this._wrapped.textureBindingViewDimension === "2d-array" ? layer : undefined;
            for (let level = 1; level < this._wrapped.mipLevelCount; level++) {
                const group = this.device.wrapped.createBindGroup({
                    label: "mipmap group",
                    layout: pipeline.getBindGroupLayout(0),
                    entries: [
                        { binding: 0, resource: this.mipLevel("2d", level - 1, l) },
                        { binding: 1, resource: sampler.sampler }
                    ]
                });
                this.device.enqueueCommands("mipmapping", encoder => {
                    encoder.renderPass({
                        colorAttachments: [{
                                storeOp: "store",
                                loadOp: "clear",
                                clearValue: { r: 0, g: 0, b: 0, a: 0 },
                                view: this.mipLevel("2d", level, l),
                            }]
                    }, pass => {
                        pass.setPipeline(pipeline);
                        pass.setBindGroup(0, group);
                        pass.draw(3);
                    });
                });
            }
        }
    }
    mipLevel(dimension, level, layer) {
        return this.createView({
            ...(layer !== undefined ? { baseArrayLayer: layer, arrayLayerCount: 1 } : {}),
            baseMipLevel: level,
            mipLevelCount: 1,
            dimension
        }).view;
    }
}
export class TextureView {
    constructor(texture, descriptor = undefined) {
        this.texture = texture;
        this.descriptor = descriptor;
        this.view = texture.wrapped.createView(descriptor);
    }
    get label() {
        return this.descriptor?.label ?? this.texture.label;
    }
    colorAttachment(clearValue = undefined) {
        return {
            view: this.view,
            storeOp: clearValue === undefined || this.texture.isAnyOf("COPY_SRC", "TEXTURE_BINDING") ? "store" : "discard",
            loadOp: clearValue === undefined ? "load" : "clear",
            clearValue: clearValue,
        };
    }
    depthAttachment(clearValue = 1) {
        return {
            view: this.view,
            depthStoreOp: clearValue === undefined || this.texture.isAnyOf("COPY_SRC", "TEXTURE_BINDING") ? "store" : "discard",
            depthLoadOp: clearValue === undefined ? "load" : "clear",
            depthClearValue: clearValue,
            stencilReadOnly: true,
        };
    }
    asBindingResource() {
        return this.view;
    }
}
export class Sampler {
    constructor(device, descriptor = undefined) {
        this.device = device;
        this.descriptor = descriptor;
        this.sampler = this.device.wrapped.createSampler(descriptor);
    }
    get label() {
        return this.descriptor?.label ?? "sampler";
    }
    asBindingResource() {
        return this.sampler;
    }
}
