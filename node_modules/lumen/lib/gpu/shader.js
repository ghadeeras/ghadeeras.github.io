import * as utl from "./utils.js";
export class ShaderModule {
    constructor(label, device, code) {
        this.label = label;
        this.device = device;
        this.descriptor = { code, label };
        this.wrapped = this.device.wrapped.createShaderModule(this.descriptor);
        if (this.wrapped === null) {
            throw new Error("Module compilation failed!");
        }
    }
    async hasCompilationErrors() {
        if (!this.wrapped.getCompilationInfo) {
            // TODO remove check when compilationInfo becomes supported in all browsers. 
            return false;
        }
        const info = await this.wrapped.getCompilationInfo();
        for (const message of info.messages) {
            switch (message.type) {
                case "info":
                    console.log(message);
                    break;
                case "warning":
                    console.warn(message);
                    break;
                case "error":
                    console.error(message);
                    break;
                default:
            }
        }
        return info.messages.some(m => m.type == "error");
    }
    computePipeline(entryPoint) {
        return this.device.wrapped.createComputePipeline({
            compute: {
                module: this.wrapped,
                entryPoint: entryPoint,
            },
            layout: "auto",
            label: `${this.wrapped.label}/${entryPoint}`
        });
    }
    vertexState(entryPoint, buffers) {
        const index = [0];
        return {
            module: this.wrapped,
            entryPoint: entryPoint,
            buffers: buffers.map(buffer => {
                if (typeof buffer == 'number') {
                    index[0] += buffer;
                    return null;
                }
                return {
                    ...buffer,
                    attributes: [...buffer.attributes].map(attribute => ({
                        ...attribute,
                        shaderLocation: index[0]++
                    }))
                };
            })
        };
    }
    fragmentState(entryPoint, targets) {
        return {
            module: this.wrapped,
            entryPoint: entryPoint,
            targets: targets.map(target => target !== null
                ? utl.asColorTargetState(target)
                : null)
        };
    }
    static async instances(device, descriptors, labelPrefix) {
        const result = {};
        const tuplePromises = Object.entries(descriptors).map(async ([k, d]) => ({
            key: k,
            module: await ShaderModule.instance(device, utl.withLabel(d, labelPrefix, k))
        }));
        const tuples = await Promise.all(tuplePromises);
        for (const tuple of tuples) {
            result[tuple.key] = tuple.module;
        }
        return result;
    }
    static async instance(device, descriptor) {
        return descriptor.path !== undefined
            ? await remoteShaderModule(device, descriptor.label ?? "shader", descriptor.path, descriptor.templateFunction)
            : await inMemoryShaderModule(device, descriptor.label ?? "shader", descriptor.code, descriptor.templateFunction);
    }
}
async function remoteShaderModule(device, label, relativePath, templateFunction = s => s, basePath = "") {
    const response = await fetch(`${basePath}/${relativePath}`, { method: "get", mode: "no-cors" });
    const rawShaderCode = await response.text();
    return await inMemoryShaderModule(device, label, rawShaderCode, templateFunction);
}
async function inMemoryShaderModule(device, label, rawShaderCode, templateFunction = s => s) {
    const shaderCode = templateFunction(rawShaderCode);
    const shaderModule = new ShaderModule(label, device, shaderCode);
    if (await shaderModule.hasCompilationErrors()) {
        throw new Error("Module compilation failed!");
    }
    return shaderModule;
}
export const renderingShaders = {
    fullScreenPassVertex: (fragmentShader) => /*wgsl*/ `
        struct Varyings {
            @builtin(position) position: vec4<f32>,
            @location(0) clipPosition: vec2<f32>,
        };
        
        const triangle: array<vec2<f32>, 3> = array<vec2<f32>, 3>(
            vec2(-1.0, -1.0),
            vec2( 3.0, -1.0),
            vec2(-1.0,  3.0),
        );
        
        @vertex
        fn v_main(@builtin(vertex_index) i: u32) -> Varyings {
            let clipPosition: vec2<f32> = triangle[i];
            return Varyings(vec4<f32>(clipPosition, 0.0, 1.0), clipPosition);
        }
    
        ${fragmentShader}
    `,
    fullScreenPass: (shader) => renderingShaders.fullScreenPassVertex(/*wgsl*/ `
        ${shader}

        @fragment
        fn f_main(varyings: Varyings) -> @location(0) vec4<f32> {
            let pixelSizeX =  dpdx(varyings.clipPosition.x); 
            let pixelSizeY = -dpdy(varyings.clipPosition.y); 
            let aspect = pixelSizeY / pixelSizeX;
            let positionAndSize = select(
                vec3(varyings.clipPosition.x, varyings.clipPosition.y / aspect, pixelSizeX),
                vec3(varyings.clipPosition.x * aspect, varyings.clipPosition.y, pixelSizeY),
                aspect >= 1.0
            );
            return colorAt(positionAndSize.xy, aspect, positionAndSize.z);
        }  
    `)
};
