import * as utl from "./utils.js";
export class BindGroup {
    constructor(layout, label, entries) {
        this.layout = layout;
        this.label = label;
        this.entries = entries;
        this.device = layout.device;
        this.wrapped = layout.device.wrapped.createBindGroup({
            label: `group ${layout.label} / ${label}`,
            layout: layout.wrapped,
            entries: Object.keys(entries).map(key => ({
                binding: layout.entries[key].binding,
                resource: entries[key].asBindingResource()
            }))
        });
    }
}
export class BindGroupLayout {
    constructor(device, label, entries) {
        this.device = device;
        this.label = label;
        this.entries = entries;
        this.wrapped = device.wrapped.createBindGroupLayout({
            label,
            entries: Object.values(entries).map(entry => entry.wrapped)
        });
    }
    asEntry(group) {
        return {
            group,
            layout: this
        };
    }
    bindGroups(descriptors, labelPrefix) {
        const bindGroups = {};
        for (const key in descriptors) {
            bindGroups[key] = this.bindGroup(descriptors[key], utl.label(labelPrefix, key));
        }
        return bindGroups;
    }
    bindGroup(entries, label) {
        return new BindGroup(this, label ?? this.labelFrom(entries), entries);
    }
    labelFrom(entries) {
        return `[ ${Object.keys(entries)
            .sort((a, b) => this.entries[a].binding - this.entries[b].binding)
            .map(key => `${key}: ${entries[key].label}`)
            .join(", ")} ]`;
    }
    static instances(device, descriptors, labelPrefix) {
        const layouts = {};
        for (const key in descriptors) {
            layouts[key] = BindGroupLayout.instance(device, descriptors[key], utl.label(labelPrefix, key));
        }
        return layouts;
    }
    static instance(device, entries, label) {
        return new BindGroupLayout(device, label ?? BindGroupLayout.labelFrom(entries), entries);
    }
    static labelFrom(entries) {
        return `[ ${Object.keys(entries)
            .sort((a, b) => entries[a].binding - entries[b].binding)
            .map(key => `${key}: ${entries[key].resource.constructor.name}`)
            .join(", ")} ]`;
    }
}
export class BindGroupLayoutEntry {
    constructor(binding, visibility, resource) {
        this.binding = binding;
        this.visibility = visibility;
        this.resource = resource;
        this.wrapped = {
            binding,
            visibility,
            ...this.resource.wrapped
        };
    }
}
export function uniform(contentType, hasDynamicOffset) {
    return bufferBindingLayout("uniform", contentType, hasDynamicOffset);
}
export function storage(accessMode, contentType, hasDynamicOffset) {
    return bufferBindingLayout(accessMode != "read" ? "storage" : "read-only-storage", contentType, hasDynamicOffset);
}
function bufferBindingLayout(type, contentType, hasDynamicOffset) {
    return new BufferBindingLayout({
        type,
        minBindingSize: contentType.size,
        hasDynamicOffset
    }, contentType);
}
export function texture_storage_1d(format, accessMode = "write") {
    return texture_storage("1d", format, accessMode);
}
export function texture_storage_2d(format, accessMode = "write") {
    return texture_storage("2d", format, accessMode);
}
export function texture_storage_2d_array(format, accessMode = "write") {
    return texture_storage("2d-array", format, accessMode);
}
export function texture_storage_3d(format, accessMode = "write") {
    return texture_storage("3d", format, accessMode);
}
function texture_storage(viewDimension, format, accessMode) {
    return new TextureStorageBindingLayout({
        viewDimension,
        format,
        access: accessMode == "read" ? "read-only" : accessMode == "write" ? "write-only" : "read-write",
    });
}
export function texture_1d(sampleType) {
    return texture("1d", sampleType);
}
export function texture_2d(sampleType) {
    return texture("2d", sampleType);
}
export function texture_2d_array(sampleType) {
    return texture("2d-array", sampleType);
}
export function texture_cube(sampleType) {
    return texture("cube", sampleType);
}
export function texture_cube_array(sampleType) {
    return texture("cube-array", sampleType);
}
export function texture_3d(sampleType) {
    return texture("3d", sampleType);
}
export function texture_depth_2d(sampleType) {
    return texture("2d", sampleType);
}
export function texture_depth_2d_array(sampleType) {
    return texture("2d-array", sampleType);
}
export function texture_depth_cube(sampleType) {
    return texture("cube", sampleType);
}
export function texture_depth_cube_array(sampleType) {
    return texture("cube-array", sampleType);
}
export function texture_multisampled_2d(sampleType) {
    return texture("2d", sampleType, true);
}
export function texture_depth_multisampled_2d(sampleType) {
    return texture("2d", sampleType, true);
}
export function texture_external(sampleType) {
    return texture("2d", sampleType);
}
function texture(viewDimension, sampleType, multisampled) {
    return new TextureBindingLayout({ viewDimension, sampleType, multisampled });
}
export function sampler(type = "filtering") {
    return new SamplerBindingLayout({ type });
}
export function sampler_comparison() {
    return new SamplerBindingLayout({ type: "comparison" });
}
export class ResourceBindingLayout {
    constructor(wrapped) {
        this.wrapped = wrapped;
    }
    asEntry(binding, stage, ...otherStages) {
        const visibility = otherStages.reduce((v, s) => v | GPUShaderStage[s], GPUShaderStage[stage]);
        return new BindGroupLayoutEntry(binding, visibility, this);
    }
}
export class BufferBindingLayout extends ResourceBindingLayout {
    constructor(buffer, contentType) {
        super({ buffer });
        this.buffer = buffer;
        this.contentType = contentType;
    }
}
export class TextureStorageBindingLayout extends ResourceBindingLayout {
    constructor(storageTexture) {
        super({ storageTexture });
        this.storageTexture = storageTexture;
    }
}
export class TextureBindingLayout extends ResourceBindingLayout {
    constructor(texture) {
        super({ texture });
        this.texture = texture;
    }
}
export class SamplerBindingLayout extends ResourceBindingLayout {
    constructor(sampler) {
        super({ sampler });
        this.sampler = sampler;
    }
}
