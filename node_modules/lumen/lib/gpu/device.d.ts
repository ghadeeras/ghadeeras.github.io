import * as pln from "./pipeline.js";
import * as shd from "./shader.js";
import * as grp from "./group.js";
import * as buf from "./buffer.js";
import { Canvas } from "./canvas.js";
import { CommandEncoder } from "./encoder.js";
import { Texture, Sampler } from "./texture.js";
export type DeviceDescriptor = {
    gpuDeviceDescriptor?: (adapter: GPUAdapter) => Promise<GPUDeviceDescriptor>;
    xrCompatible?: boolean;
};
export declare class Device {
    private _wrapped;
    private deviceDescriptor;
    private destructionListeners;
    private recoveryListeners;
    constructor(_wrapped: GPUDevice, deviceDescriptor: DeviceDescriptor);
    private handleDeviceLoss;
    get wrapped(): GPUDevice;
    /**
     * @deprecated Use `wrapped` instead.
     */
    get device(): GPUDevice;
    addDestructionListener(listener: () => void): () => void;
    addRecoveryListener(listener: () => void): () => void;
    private addListener;
    shaderModules<D extends shd.ShaderModuleDescriptors>(descriptors: D): Promise<shd.ShaderModules<D>>;
    shaderModule(label: string, descriptor: shd.ShaderModuleDescriptor): Promise<shd.ShaderModule>;
    loadShaderModule(relativePath: string, templateFunction?: (code: string) => string, basePath?: string): Promise<shd.ShaderModule>;
    remoteShaderModule(label: string, relativePath: string, templateFunction?: (code: string) => string, basePath?: string): Promise<shd.ShaderModule>;
    inMemoryShaderModule(label: string, rawShaderCode: string, templateFunction?: (code: string) => string): Promise<shd.ShaderModule>;
    enqueueCommands(name: string, ...encodings: ((encoder: CommandEncoder) => void)[]): void;
    enqueueCommand(name: string, encoding: (encoder: CommandEncoder) => void): void;
    enqueue(...commands: GPUCommandBuffer[]): void;
    commands(name: string, ...encodings: ((encoder: CommandEncoder) => void)[]): GPUCommandBuffer[];
    command(name: string, encoding: (encoder: CommandEncoder) => void): GPUCommandBuffer;
    canvas(element: HTMLCanvasElement | string, sampleCount?: number): Canvas;
    texture(descriptor: GPUTextureDescriptor): Texture;
    sampler(descriptor?: GPUSamplerDescriptor | undefined): Sampler;
    dataBuffers<D extends buf.DataBufferDescriptors>(descriptors: D): buf.DataBuffers<D>;
    dataBuffer(label: string, descriptor: buf.DataBufferDescriptor): buf.DataBuffer;
    readBuffers<D extends buf.ReadBufferDescriptors>(descriptors: D): buf.ReadBuffers<D>;
    readBuffer(label: string, size: number): buf.ReadBuffer;
    writeBuffers<D extends buf.WriteBufferDescriptors>(descriptors: D): buf.WriteBuffers<D>;
    writeBuffer(label: string, data: DataView): buf.WriteBuffer;
    syncBuffers<D extends buf.DataBufferDescriptors>(descriptors: D): buf.SyncBuffers<D>;
    syncBuffer(label: string, descriptor: buf.DataBufferDescriptor): buf.SyncBuffer;
    groupLayouts<D extends grp.BindGroupLayoutDescriptors>(descriptors: D): grp.BindGroupLayouts<D>;
    groupLayout<D extends grp.BindGroupLayoutDescriptor>(label: string, descriptor: D): grp.BindGroupLayout<D>;
    pipelineLayouts<D extends pln.PipelineLayoutDescriptors>(descriptors: D): pln.PipelineLayouts<D>;
    pipelineLayout<D extends pln.PipelineLayoutDescriptor>(label: string, descriptor: D): pln.PipelineLayout<D>;
    suggestedGroupSizes(): number[][];
    monitorErrors<T>(filter: GPUErrorFilter, expression: () => T): Promise<T>;
    static instance(deviceDescriptor?: DeviceDescriptor): Promise<Device>;
}
